## HTTP

> 三次握手 `在我看来 就是 你好 我好 大家好的 状态下 才能确定已经真正为连接做好准备`

- 第一次握手：建立连接，客户端发送 syn 包 到服务器，等待服务器确认
- 第二次握手：服务器收到 syn 包，确认客户端 SYN，同时也发送一个SYN 包，即 SYN + ACK 包
- 第三次握手：客户端收到服务器的 SYN + ACK 包，向服务器发送确认包 ACK 连接成功

  
  
> 四次挥手

- 客户端发送一个 FIN，用来关闭与服务器之间的数据传送
- 服务器收到 FIN，发回一个 ACK
- 服务器关闭与客户端的连接，发送一个 FIN
- 客户端发回 ACK 确认


为什么需要四次：
    这是因为服务端在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。而关闭连接时，当收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，己方也未必全部数据都发送给对方了，所以己方可以立即close，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送。


> 浏览器阻塞 (HOL blocking)

- 一般 PC 浏览器对单个域名的 server 同时建立 6~8 个连接，移动端上一般 4~6 个，所以 在大型网站上 一般会把静态资源放在不同于域名下，来加快浏览器渲染速度



## HTTP2.0

- 二进制分帧： HTTP2.0 的所有帧都采用二进制编码  
   1、帧：  客户端与服务器通过交换帧来通信，帧是基于新协议通信的最小单位  
   2、消息：指逻辑上的 HTTP 消息，比如请求、响应等由一个或多个帧组成  
   3、流：  流是连接中一个虚拟信道，可以承载双向消息；每个流都有一个唯一的整数标识符  
   
- 多路复用 Multiplexing  
    多路复用允许同时通过单一的 HTTP 连接发起多重 请求-响应 消息，有了新的分帧机制，不必再依赖多个 TCP 连接去实现多流并行。  
    每个数据流都拆分成很多互不依赖的帧(可以乱序发送，可以分优先级)

- 请求优先级  
    把 HTTP 消息分解为很多独立的帧之后，就可以通过优化这些帧的交错和传输顺序，每个流都可以带有一个31比特的优先值：0表示最高优先级，2^31-1 表示最低优先级  
    服务器可以根据流的优先级，控制分配资源，优先将最高优先级的帧发送给客户端

- header 压缩  
    HTTP1.X 的 header 带有大量信息，并且每次都要重复发送， HTTP2.0 使用 encoder 来减少需要传输的 header 大小，通讯顺发各自 cacha 一份 header fields 表   

- 服务器推送  
    一言以蔽之 就是 客户端请求 index.html，服务器把所需要的资源随着 index.html 一起发送到客户端，省去了客户端请求的步骤。  
    服务器可以对一个客户端请求发送多个响应，无需客户端明确地请求。所有推送的资源都遵守同源策略   


## HTTPS

- `https` 实际就是讲 `http` 通信放到 `SSL` 之上进行的。
- `SSL` (Secure Socket Layer：安全套接字层) 是一种通过公钥基础设施为通信双方提供数据加密和身份验证的协议。之后用 IETF(Internet Engineering Task Force：互联网工程任务组)接受并将其改名为 `TLS` (Transport Layer Security：传输层安全协议)。  
- `SSL` 和 `TLS` 两者可以视为同一个东西不同阶段的产物




**应用层**

### HTTP  

当我们在浏览器中输入 https://www.xxx.xxx 的时候  
这个URL 叫做统一资源定位符  之所以叫统一  是因为有格式的  
当我们把这样一个字符串输入到浏览器的时候 才知道如何进行统一处理  

浏览器会将域名发送给 `DNS` 服务器解析为 `IP` 地址 先建立 `TCP` 连接 
确保这是一次 稳定、可靠的连接  建立连接之后 浏览器就会发送 `HTTP` 请求

`HTTP` 报文大概分为三大部分
- 请求行
- 请求首部
- 请求正文实体 

`HTTP` 协议是基于 `TCP` 协议的 所以使用面向连接的方式发生请求 通过 `stream` 二进制流  
方式传给对方  到了 `TCP` 层 会把二进制流变成一个个的报文段发生给服务器  
在发送每个报文段的时候 都需要对方有个回应 `ACK` 来保证已经到达了 如果没有收到回应  
那么 `TCP` 层会进行重新传输 直到到达 同一个包可能被传了很多次 `HTTP` 层不需要知道这点  
`TCP` 层发送每一个报文的时候 都加上了自己的地址和目标地址 将这两个信息放在 `IP` 头里  
交给 `IP` 层进行传输  
`IP` 层查看目标地址和自己是否是在同一局域网里 如果是 就发送 `ARP` 协议来请求这个目标地址  
对应的 `MAC` 地址 然后将 源 `MAC` 和目标 `MAC` 放入 `MAC` 头 发送出去  如果不是在同一局域网里  
就需要发送到网关 网关收到包 取出 目标 `IP` 地址 根据路由协议找到下一跳的路由器  获取下个路由器的 `MAC` 地址  
终于到达目标的局域网  
目标的机器发现 `MAC` 地址符合 就将包收起来 发现 `IP` 地址符合 根据 `IP` 头中协议项  
知道自己上一层是 `TCP` 协议 于是解析 `TCP` 的头 里面有序列号 需要看一看这个序列包是不是我要的  
如果是就放入缓存中然后返回一个 `ACK` 如果不是就丢弃  
`TCP` 头里面还有端口号 `HTTP` 的服务器正在监听这个端口号 于是 目标机器自然知道是 `HTTP` 服务器这个进程想要这个包  
于是将包发给 `HTTP` 服务器 `HTTP` 服务器的进程看到 原来这个请求是要访问一个网页 于是就把这个网页发给客户端  

**HTTP 2.0**  
`HTTP 1.1` 在应用层以纯文本的形式进行通信  每次都要带完整的 `HTTP` 头 实时性、并发性都存在问题  
`HTTP 2.0` 会都 `HTTP` 头进行一定的压缩 将每次都要携带的大量 `key value` 在两端建立一个索引表  
对相同头只发送索引表中的索引  
`HTTP 2.0` 将 `TCP` 连接中 切分成多个流 每个流都有自己的 ID 而且流可以是从客户端发往服务端 也可以说是服务端发往客户端  
一个虚拟的通道 流是有优先级的
`HTTP 2.0` 将所有的传输信息分割为更小的消息和帧 并采用二进制格式编码  
  
假设一个页面要发送三个独立的请求 一个 css  一个js  一个图片  
`HTTP 1.1` 就是串行的  但如果使用 `HTTP 2.0` 就可以在一个连接里  
客户端和服务器都可以同时发送多个请求或回应 减少了 `TCP` 连接数对服务器性能的影响 而且还能加快页面传输速度  

**QUIC 协议**
但是 `HTTP 2.0` 还是基于 `TCP` 在处理包时有严格顺序的..... 
 

