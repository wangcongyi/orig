### TCP 协议

<img src="https://github.com/wangcongyi/test/blob/master/images/tcp.png" width="70%">

首先 源端口号和目标端口号 如果没有这两个端口号 数据就不知道应该发给哪个应用  

接下来是包的序号  给包编号就是为了解决乱序的问题  
确认序号 就是发出去的包应该有确认 不然怎么知道对方有没有收到呢  
如果没有收到就应该重新发送 直到送达成功  解决不丢包的问题  
`TCP` 在网络状态不理想的情况下 是没有任何可靠性保证的 唯一能做的  
就是通过各种算法保证  更加努力 不断重传  

接下来有一些状态位  `TCP` 是面向连接的 因而双方要维护连接的状态 这些状态位会引起双方的状态变更
- SYN 是发起一个连接  
- ACK 是回复  
- RST 是重新连接 
- FIN 断开连接（结束连接）

窗口大小是指 `TCP`做的流量控制 通信双方各声明一个窗口 标识自己当前能够处理的能力 发送快慢  


**TCP 三次握手**
- 为什么是三次
    请求 -->> 应答 -->> 应答之应答
三次握手除了双方建立连接外 还是为了确定 `TCP` 包序号的问题  
A 要告诉 B 发起的包的序号是从哪个开始的 B 同样也要告诉 A  
每个连接都要有不同的序号 这个序号的起始序号是随着时间变化的  

一开始 客户端和服务器都处于 `CLOSED` 状态  
服务器主动监听某个端口  处于 `LISTEN` 状态  
客户端主动发起连接 `SYN`  处于 `SYN-SENT` 状态  
服务端收到 `SYN` 并且 `ACK` 客户端的 `SYN` 处于 `SYN-RCVD` 状态  
客户端收到服务端发来的 `SYN` `ACK` 后 发送 `ACK` 的 `ACK`  处于 `ESTABLISHED` 状态  一发一收成功  
服务端收到 `ACK` 的 `ACK` 后 就处于 `ESTABLISHED` 状态 一发一收也成功了  


**TCP 四次挥手**
A: B啊 我想和你分手  
B: 哦 你想分手了啊  我知道了....

A先说分手 也即A不会再发送数据 但B能不能在`ACK`的时候直接关闭呢？  
当然不能 很有可能A是发送完最后的数据就准备不玩了 但B还没有做完自己的事 称为半关闭状态  
这时候 A 可以选择不再接受数据也可以选择最后再接受一段数据 等待B也主动关闭  

B: A啊 好啊  我也想分手了 拜拜...
A: 好的 拜拜

这样整个连接就关闭了 属于和平分手~  


客户端说 断开连接  进入 `FIN_WAIT_1` 状态  
服务端收到 消息后 发送知道了  进入 `CLOSE_WAIT` 状态  
客户端收到 服务端的消息 进入 `FIN_WAIT_2` 状态  
    如果服务端直接走人 客户端将永远处于这个状态    
    `TCP` 协议里并没有对这个状态的处理 但 `Linux` 有 可以调整 `tcp_fin_timeout` 设置超时时间  
服务端 发送 `ACK` 消息 '服务端也想分手'的请求到客户端  
客户端收到服务端的 `ACK` 消息 也发送一个 `ACK`消息给服务端  
    按理说已经可以甩头走人了 但最后这个 `ACK` 万一服务端收不到呢  
    服务端不知道 客户端已经走人了 有可能发过的很多包还在路上 基本上全部死翘翘
    因而 `TCP` 协议要求 客户端最后等待一段时间 ‘TIME_WAIT’  
    等待时间 一般为 2MSL `Maximun segment lifetime` 报文最大生存时间  
服务器接收到 `FIN` 的 `ACK` 断开连接
    如果服务端超过 2MSL 依然没有收到 按照 `TCP` 原来 服务端会重发 `FIN`  
    但客户端表示 已经等你很久了 仁至义尽了 之后的就不认了 直接发送 `RST`  
    服务器就知道客户端早就跟人跑了

![tcp](https://github.com/wangcongyi/test/blob/master/images/tcp2.png)
