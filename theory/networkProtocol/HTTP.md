## HTTP

> 三次握手 `在我看来 就是 你好 我好 大家好的 状态下 才能确定已经真正为连接做好准备`

- 第一次握手：建立连接，客户端发送 syn 包 到服务器，等待服务器确认
- 第二次握手：服务器收到 syn 包，确认客户端 SYN，同时也发送一个SYN 包，即 SYN + ACK 包
- 第三次握手：客户端收到服务器的 SYN + ACK 包，向服务器发送确认包 ACK 连接成功

  
  
> 四次挥手

- 客户端发送一个 FIN，用来关闭与服务器之间的数据传送
- 服务器收到 FIN，发回一个 ACK
- 服务器关闭与客户端的连接，发送一个 FIN
- 客户端发回 ACK 确认


为什么需要四次：
    这是因为服务端在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。而关闭连接时，当收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，己方也未必全部数据都发送给对方了，所以己方可以立即close，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送。


> 浏览器阻塞 (HOL blocking)

- 一般 PC 浏览器对单个域名的 server 同时建立 6~8 个连接，移动端上一般 4~6 个，所以 在大型网站上 一般会把静态资源放在不同于域名下，来加快浏览器渲染速度


**应用层**

### HTTP  

当我们在浏览器中输入 https://www.xxx.xxx 的时候  
这个URL 叫做统一资源定位符  之所以叫统一  是因为有格式的  
当我们把这样一个字符串输入到浏览器的时候 才知道如何进行统一处理  

浏览器会将域名发送给 `DNS` 服务器解析为 `IP` 地址 先建立 `TCP` 连接 
确保这是一次 稳定、可靠的连接  建立连接之后 浏览器就会发送 `HTTP` 请求

`HTTP` 报文大概分为三大部分
- 请求行
- 请求首部
- 请求正文实体 

`HTTP` 协议是基于 `TCP` 协议的 所以使用面向连接的方式发生请求 通过 `stream` 二进制流  
方式传给对方  到了 `TCP` 层 会把二进制流变成一个个的报文段发生给服务器  
在发送每个报文段的时候 都需要对方有个回应 `ACK` 来保证已经到达了 如果没有收到回应  
那么 `TCP` 层会进行重新传输 直到到达 同一个包可能被传了很多次 `HTTP` 层不需要知道这点  
`TCP` 层发送每一个报文的时候 都加上了自己的地址和目标地址 将这两个信息放在 `IP` 头里  
交给 `IP` 层进行传输  
`IP` 层查看目标地址和自己是否是在同一局域网里 如果是 就发送 `ARP` 协议来请求这个目标地址  
对应的 `MAC` 地址 然后将 源 `MAC` 和目标 `MAC` 放入 `MAC` 头 发送出去  如果不是在同一局域网里  
就需要发送到网关 网关收到包 取出 目标 `IP` 地址 根据路由协议找到下一跳的路由器  获取下个路由器的 `MAC` 地址  
终于到达目标的局域网  
目标的机器发现 `MAC` 地址符合 就将包收起来 发现 `IP` 地址符合 根据 `IP` 头中协议项  
知道自己上一层是 `TCP` 协议 于是解析 `TCP` 的头 里面有序列号 需要看一看这个序列包是不是我要的  
如果是就放入缓存中然后返回一个 `ACK` 如果不是就丢弃  
`TCP` 头里面还有端口号 `HTTP` 的服务器正在监听这个端口号 于是 目标机器自然知道是 `HTTP` 服务器这个进程想要这个包  
于是将包发给 `HTTP` 服务器 `HTTP` 服务器的进程看到 原来这个请求是要访问一个网页 于是就把这个网页发给客户端  

 

