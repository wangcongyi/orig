#### 协议

```js
function Hello(){
  console.log('hello world')
}
```
每一个程序员向计算机世界说 '你好世界'  
这一段也是一种协议，是人类和计算机沟通的协议  
`只有通过这种协议 计算机才知道我们想让它做什么`

#### 网络协议
在浏览器里输入 https://www.baidu.com 这是一个 `URL`  
浏览器只知道名字 但不知道具体的地点 通过 地址簿协议 `DNS`  
或者使用另一种更加精准的 `HTTPDNS`  
无论哪种方法查找 最终都会得到 `IP` 地址（互联网世界的 ‘门牌号’）  

`DNS` `HTTP` `HTTPS` 所在的层 我们称之为 **应用层**  
浏览器会将应用层的包交给下一层 **传输层** 通过 `socket` 编程完成实现  
  
**传输层** 封装完毕之后 浏览器会将包交给操作系统的 **网络层**
- 无连接协议 `UDP`  
- 面向连接协议 `TCP` 会保证这个包能够到达目的地 如果不能就重新发送 直到成功  
  
**网络层** 的协议就是 `IP` 协议  
在 `IP` 协议里面会有源 `IP` 地址 即浏览器所在机器的 `IP` 地址和目标 `IP` 地址
  
操作系统知道了目标 `IP` 就开始根据中国门牌号找目标机器  
操作系统启动的时候就会被 `DHCP` 协议配置 `IP` 地址 以及默认网关 IP 地址 `192.168.1.1`  
操作系统如何将 `IP` 地址发给网关呢？在本地通信基本靠吼，于是操作系统大吼一声，谁是 `192.168.1.1` 啊  
网关会回答它，我就是，我的本地地址在村东头。这个本地地址就是 MAC 地址，而大吼的那一声是 ARP 协议
操作系统将 `IP` 包交给了下一层 也就是 **MAC层**  
  
| | |
|:----:|:----|
| 应用层 | DHCP HTTP HTTPS RTMP P2P DNS GTP RPC |
| 传输层 | UDP TCP |
| 网络层 | ICMP IP OSPF BGP IPSec GRE |
| 链路层 | ARP VLAN STP|
| 物理层 | 网络跳线 |


**动态主机配置协议（DHCP）**  
dynamic host configuration protocol

网络管理员只需要配置一段共享的 `IP` 地址  
每一台新接入的机器都通过 `DHCP` 协议 来这个共享`IP`地址里申请  
数据中心里面的服务器 一旦`IP`配置好 就基本不会变 相当于买房自己装修  
`DHCP` 方式相当于租房 你不用装修 我帮你配置好  你暂时用一下 用完退组就跨域了  

当一台机器新加入一个网络的时候 只知道自己的 `MAC` 地址 这时候基本沟通基本靠吼  
新来的机器使用`IP`地址0.0.0.0 发送一个广播包 目的`IP`为 255.255.255.255  
广播包封装了 `UDP`  `UDP` 封装了 `BOOTP`  
在广播包里 新人大喊一声 我是新来的  我的`MAC`地址是这个  我还没有`IP`谁能给租个`IP`给我  
`IP`管理员（DHCP Server）知道来了一个新人 保留了提供的`IP`地址 从而不会为其他的新人分配此`IP`地址  
新来的机器得到了回复 向网络发送 `DHCP Request` 广播包 告诉`DHCP`服务器 已经接纳  
此时由于还没有得到服务器最后确认 新来的机器仍使用`0.0.0.0`为源 `255.255.255.255`为目的地址进行广播  
在`DHCP server` 接收到新来的机器 `DHCP Request` 广播包 会返回 `DHCP ACK` 消息包  
将这个`IP`地址合法信息和其他配置信息发给新人 欢迎加入网络大家庭  达成协议还需要广播一下让大家都知道  
既然是租房子 合同到期 管理员就要将`IP`收回  不续约的话 收回完事  续约的话就要提前一段时间给 `DHCP server` 说  
`DHCP` 协议主要是用来给客户租用 IP 地址，和房产中介很像，要商谈、签约、续租，广播还不能“抢单”   


**物理层（第一层）**  
网线~ 1-3、2-6 交叉接法  
水晶头的第 1、2 和第 3、6 脚，它们分别起着收、发信号的作用  
将一端的 1 号和 3 号线、2 号和 6 号线互换一下位置，就能够在物理层实现一端发送的信号，另一端能收到  
除了网线 还需要配置 两台电脑的 IP地址、子网掩码和默认网关 
两台电脑直接的网络包也需要 MAC层  IP层封装了MAC层才能将包放入物理层  
两台电脑已经构成了最小的局域网（LAN）  


广播的传送数据模式 —— 每一台电脑发出的包 局域网的每一台电脑都能收到就麻烦了：  
这个包是发送给谁的？谁应该接受？  
大家都在发 产生混乱怎么办？ 有没有先发后发的规则？  
如果发送的时候出现了错误 怎么办？    
上述问题都在第二层解决

**数据链路层（第二层）**  
数据链路层也即 MAC 层 全称 `medium access control`  
控制再往媒体上发送数据的时候 谁先发 谁后发的问题 防止混乱  很多算法可以解决这个问题  
- 分多个车道 每个车一个车道 你走你的 我走我的  `信道划分`  
- 今天单号出现 明天双号出现 轮着来 `轮流协议`
- 不管啥 有事先出门 发现特堵就回去 错过高峰再出行 `随机接入协议`  

发给谁？谁接受的问题 用物理地址 叫做 `链路层地址`  常被称为 `MAC地址`  
第二层网络包格式 就是目标 MAC地址 和源 MAC 地址  
大部分类型是`IP`数据包 里面包含了 `TCP` `UDP` 以及 `HTTP`  
有了目标 MAC地址 数据包在链路上广播 MAC网卡才能发现 这个包是给谁的  
MAC 网卡把包收进来 打开IP包 发现IP地址也是自己的 再打开TCP包 发现端口是 80（这里默认web开发 nginx监听80端口）  
将请求提交给 监听80端口的程序（nginx）  nginx 返回一个网页。然后将网页需要发回请求的机器  
然后层层封装 最后到 MAC 层 因为来的时候有源 MAC 地址 返回的时候，源 MAC 就变成了目标 MAC 再返给请求的机器 
这里还有一个问题  当源机器知道目标机器的时候 可以将目标地址放入包里 如果不知道呢？  
一个广播的网络里接入了 N 台机器 我怎么知道每个 MAC 地址是谁呢？  
这里需要 `ARP 协议`  就是 已知 IP 求 MAC地址的 协议  
在一个局域网里 知道了 IP 不知道 MAC 怎么办？  还是靠吼~~  
为了避免每次都使用 `ARP` 请求 机器本地也会进行缓存 当然缓存一段时间就会过期  

广播方式随着机器越来越多 产生的冲突概率也就提高了 而且把不需要的包转发过去 纯属浪费  
`交换机` -- 一台电脑将一个包发送给另一台电脑 当包到达交换机的时候也不知道地址 只能将包转发给除了来的那个电脑  
其他所有的电脑上  这里 `交换机就会记住 源电脑的地址` 以后有包的目的地是 这个 就直接发送  
这样交换机作为一个关卡一样  过一段时间之后 就有了整个网络的结构了 这时候就不用广播了 全部可以准确转发  
交换机的结果 我们称之为 `转发表` 也是有一个过期时间的  

随着新接入的电脑越来越多 交换机数目也越来越多  不可避免的出现一些意料不到的事  
常见的问题就是 `环路问题`  

![环路问题](https://github.com/wangcongyi/test/blob/master/images/j.png)

我们来想象一下机器 1 访问机器 2 的过程。一开始，机器 1 并不知道机器 2 的 MAC 地址，所以它需要发起一个 ARP 的广播。广播到达机器 2，机器 2 会把 MAC 地址返回来，看起来没有这两个交换机什么事情。但是问题来了，这两个交换机还是都能够收到广播包的。交换机 A 一开始是不知道机器 2 在哪个局域网的，所以它会把广播消息放到局域网二，在局域网二广播的时候，交换机 B 右边这个网口也是能够收到广播消息的。交换机 B 会将这个广播信息发送到局域网一。局域网一的这个广播消息，又会到达交换机 A 左边的这个接口。交换机 A 这个时候还是不知道机器 2 在哪个局域网，于是将广播包又转发到局域网二。左转左转左转，好像是个圈哦。可能有人会说，当两台交换机都能够逐渐学习到拓扑结构之后，是不是就可以了？别想了，压根儿学不会的。机器 1 的广播包到达交换机 A 和交换机 B 的时候，本来两个交换机都学会了机器 1 是在局域网一的，但是当交换机 A 将包广播到局域网二之后，交换机 B 右边的网口收到了来自交换机 A 的广播包。根据学习机制，这彻底损坏了交换机 B 的三观，刚才机器 1 还在左边的网口呢，怎么又出现在右边的网口呢？哦，那肯定是机器 1 换位置了，于是就误会了，交换机 B 就学会了，机器 1 是从右边这个网口来的，把刚才学习的那一条清理掉。同理，交换机 A 右边的网口，也能收到交换机 B 转发过来的广播包，同样也误会了，于是也学会了，机器 1 从右边的网口来，不是从左边的网口来。然而当广播包从左边的局域网一广播的时候，两个交换机再次刷新三观，原来机器 1 是在左边的，过一会儿，又发现不对，是在右边的，过一会，又发现不对，是在左边的。这还是一个包转来转去，每台机器都会发广播包，交换机转发也会复制广播包，当广播包越来越多的时候，按照上一节讲过一个共享道路的算法，也就是路会越来越堵，最后谁也别想走。所以，必须有一个方法解决环路的问题，怎么破除环路呢？

**STP 协议**  
在数据结构中 有一个方法叫做 `最小生成树`  将图中的环变成 树形结构  
全称 `spanning tree protocol`  
这个协议可以用 ‘华山论剑’ 来比喻

- 根交换机（root bridge） 
- 指定交换机 （designated bridges） 所谓的指定 就是 树枝
- 网桥协议数据单元 （bridge protocol data units） ‘相互比较实力’的协议 
- 优先级向量 （priority vector） ‘实力值越小越牛’ 实力值就是一组 ID 数据  

一开始 所有交互机都认为自己是掌门 每个网桥都被分配了一个 ID    
这个ID里有管理员分配的优先级知道哪些交换机好，就会给它们分配高的优先级  
既然都是掌门相互连接网线 就大家发送 `BPDU` 来比比武功呗  
赢的接着当掌门 输的就只好做小弟了  输的人就没有机会在继续发送 `BPDU` 了  
只有在收到掌门的 `BPDU` 时 转发一下 表示服从命令  
- 掌门继续比武 输掉的掌门会率领所有的小弟归顺 小的门派慢慢合并  
- 掌门有何能和自己的小弟相遇（说明已经存在`环`了） 小弟通过已经输掉的掌门拜在了你的门下  
只是掌门还不认识 发现这个小弟武功不错 不应该级别这么低  升职加薪吧~  
- 小弟与小弟相遇  比 谁和掌门的关系近 当大哥  
- 掌门和其他门派小弟相遇 赢了会逐渐拉拢和自己连接的兄弟 弃暗投明 输了 掌门就拜入门来  
- 不同门派小弟相遇 各自拿自己的掌门比较  
慢慢 武林统一 天下太平 生成一颗大树


**ICMP 协议**  
`ICMP` 全称 internet control message protocol  互联网控制报文协议  
网络包在错综复杂的网络环境中传输时 常常会遇到各种各样的问题 当遇到问题的时候  
总不能‘死的不明不白’ 要传出消息报告情况 这样才能调整传输策略  
`ICMP`报文 封装在 IP 包里 作为`侦察兵` 轻装上阵 不携带大量的包袱  

主帅说 来人呐 前方战事如何 快去派人打探 一有情况 立即速报  
这种主帅发起的 主动查看敌情 对应 `ICMP` 的 查询报文类型  
常用的 `ping 就是查询报文 十一章主动请求 并且获得主动应答的 ICMP 协议`  

主帅骑着马走着走着 突然一匹快马来报：报告将军 前方军遭遇埋伏 已经全军覆没了  
- 报告将军 送往前方军的粮草 结果没有送到 `终点不可达为`
那为啥送不到呢？
1. 找不到地方     `网络不可达 0`
2. 找到地方没有这个人     `主机不可达 1`
3. 找到地方找到人 暗号没对上     `协议不可达 2`
4. 找到地方找到人 暗号对上了 事儿没对上 我去送粮草 人家说在等救兵    `端口不可达 3`  

- 报告将军 你送的粮食太多了 吃不下  `源站抑制` 也就是让源站慢发送速度  
- 报告将军 送粮草的人 自己把粮草吃完了 还没找到地方 已经饿死啦  `时间超时`  超过网络包的生存时间还是没到  
- 报告将军 送粮草的人本来只要走一站地铁 非得从五环绕  `路由器重定向`  下次发给另一个路由器


**网关（gateway）**
网关往往是一个路由器 是一个三层转发设备  
把 `MAC` 头和 `IP` 头取下来 根据里面的内容  看看接下来把包往哪里转发的设备  

很多情况下 人们把网关就叫做路由器 其实不完全准确  另一个比喻更恰当  
路由器是一台设备 有五个网口或者网卡 分别连着五个局域网  每个网口（网卡）  
的`IP`地址都和局域网的`IP`地址相同网段  
任何一个想发往其他局域网的包 都会先到达其中一个网口 拿下`MAC` 头 `IP` 头  
根据路由算法选择另一个网口 加上 `MAC` 头 `IP` 头  再扔出去  

那该选择哪一个网口 `MAC` 头 `IP` 头  加什么内容 哪些变、哪些不变  

- 静态路由  
    1. 匹配一条一条规则 每当要选择从哪个网口抛出去的时候 就一条一条的匹配规则
    2. 每到一个新的局域网 `MAC` 都是要变的 但 `IP` 地址不变 从一个路由器跳到另一个路由器 是  
       某个 `IP` 要将这个 `IP` 地址转换为 `MAC` 放入 `MAC` 头  
       经过路由器之后 `MAC` 头要变如果 `IP` 不变 相当于不换护照的欧洲旅游(一个签证就可游历欧洲各国)
       如果 `IP` 变 相当于换护照的玄奘西行(通关文牒相当于切换身份)


**路由协议**

路由器就是一台网络设备 有多张网口(网卡)  
当一个入口网络包送到路由器时 会根据一个本地的转发信息库来决定如果正确转发  
这个转发信息库通常被称为 `路由表`

`策略路由` --- 可以配置多个路由表 根据源`IP`地址、入口设备等来选择路由表  

`动态路由算法` --- 根据路由协议算法生成动态路由表 随网络运行状况变化而变化  
想象：唐僧西天取经 如何在每个国家里找到正确的路去换通关文牒、吃饭、休息  
如何在国家之间找到正确的路...  无论是在国家内部还是国家之间 我们都可以抽象为一种图的数据结构  
那 如何在图中找到最短路径？


**传输层**

传输层比较重要的两个协议

- TCP
  1. `TCP` 是面向连接的  所谓的连接就是为了在客户端和服务端维护连接  
      而建立一定的数据结构来维护双方交互状态  
      通过 `TCP` 连接传输的数据 无差错、不丢失、不重复、按序到达  
      
  2.  `TCP` 是面向字节流的  发的是一个没头没尾的流 之所以变成了流  
      也是 `TCP` 自己状态维护做的事情  
      
  3.  `TCP` 可以有拥塞控制的 意识到包丢弃了或者网络环境不好的时候 会根据  
      情况调整自己的行为
  
  
  
- UDP
  1. `UDP` 是面向无连接的  不会像 `TCP` 协议一样会三次握手  
     `UDP` 继承`IP`包特性 不保证不丢失 不保证按序到达  
     
  2. `UDP` 基于数据包 一个一个的发 一个一个的收  
  
  3. `UDP` 不会理会网络状态和环境 应用让我发 我就发


#### MAC 地址

- MAC 地址是一个很容易让人‘误解’的地址，因为 MAC 地址号称全球唯一，不会有两个网卡有相同的 MAC 地址，  
很多人看到这里就会想，既然这样 整个互联网通信全部使用 MAC 地址就好了，但这样不行 `一个网络报要从一个传输到另一个地方，
除了需要确定的地址，还需要有定位功能`。 


