#### 协议

```js
function Hello(){
  console.log('hello world')
}
```
每一个程序员向计算机世界说 '你好世界'  
这一段也是一种协议，是人类和计算机沟通的协议  
`只有通过这种协议 计算机才知道我们想让它做什么`

#### 网络协议
在浏览器里输入 https://www.baidu.com 这是一个 `URL`  
浏览器只知道名字 但不知道具体的地点 通过 地址簿协议 `DNS`  
或者使用另一种更加精准的 `HTTPDNS`  
无论哪种方法查找 最终都会得到 `IP` 地址（互联网世界的 ‘门牌号’）  

`DNS` `HTTP` `HTTPS` 所在的层 我们称之为 **应用层**  
浏览器会将应用层的包交给下一层 **传输层** 通过 `socket` 编程完成实现  
  
**传输层** 封装完毕之后 浏览器会将包交给操作系统的 **网络层**
- 无连接协议 `UDP`  
- 面向连接协议 `TCP` 会保证这个包能够到达目的地 如果不能就重新发送 直到成功  
  
**网络层** 的协议就是 `IP` 协议  
在 `IP` 协议里面会有源 `IP` 地址 即浏览器所在机器的 `IP` 地址和目标 `IP` 地址
  
操作系统知道了目标 `IP` 就开始根据中国门牌号找目标机器  
操作系统启动的时候就会被 `DHCP` 协议配置 `IP` 地址 以及默认网关 IP 地址 `192.168.1.1`  
操作系统如何将 `IP` 地址发给网关呢？在本地通信基本靠吼，于是操作系统大吼一声，谁是 `192.168.1.1` 啊  
网关会回答它，我就是，我的本地地址在村东头。这个本地地址就是 MAC 地址，而大吼的那一声是 ARP 协议
操作系统将 `IP` 包交给了下一层 也就是 **MAC层**  
  
| | |
|:----:|:----|
| 应用层 | DHCP HTTP HTTPS RTMP P2P DNS GTP RPC |
| 传输层 | UDP TCP |
| 网络层 | ICMP IP OSPF BGP IPSec GRE |
| 链路层 | ARP VLAN STP|
| 物理层 | 网络跳线 |


**动态主机配置协议（DHCP）**  
dynamic host configuration protocol

网络管理员只需要配置一段共享的 `IP` 地址  
每一台新接入的机器都通过 `DHCP` 协议 来这个共享`IP`地址里申请  
数据中心里面的服务器 一旦`IP`配置好 就基本不会变 相当于买房自己装修  
`DHCP` 方式相当于租房 你不用装修 我帮你配置好  你暂时用一下 用完退组就跨域了  

当一台机器新加入一个网络的时候 只知道自己的 `MAC` 地址 这时候基本沟通基本靠吼  
新来的机器使用`IP`地址0.0.0.0 发送一个广播包 目的`IP`为 255.255.255.255  
广播包封装了 `UDP`  `UDP` 封装了 `BOOTP`  
在广播包里 新人大喊一声 我是新来的  我的`MAC`地址是这个  我还没有`IP`谁能给租个`IP`给我  
`IP`管理员（DHCP Server）知道来了一个新人 保留了提供的`IP`地址 从而不会为其他的新人分配此`IP`地址  
新来的机器得到了回复 向网络发送 `DHCP Request` 广播包 告诉`DHCP`服务器 已经接纳  
此时由于还没有得到服务器最后确认 新来的机器仍使用`0.0.0.0`为源 `255.255.255.255`为目的地址进行广播  
在`DHCP server` 接收到新来的机器 `DHCP Request` 广播包 会返回 `DHCP ACK` 消息包  
将这个`IP`地址合法信息和其他配置信息发给新人 欢迎加入网络大家庭  达成协议还需要广播一下让大家都知道  
既然是租房子 合同到期 管理员就要将`IP`收回  不续约的话 收回完事  续约的话就要提前一段时间给 `DHCP server` 说  
`DHCP` 协议主要是用来给客户租用 IP 地址，和房产中介很像，要商谈、签约、续租，广播还不能“抢单”   


**物理层（第一层）**  
网线~ 1-3、2-6 交叉接法  
水晶头的第 1、2 和第 3、6 脚，它们分别起着收、发信号的作用  
将一端的 1 号和 3 号线、2 号和 6 号线互换一下位置，就能够在物理层实现一端发送的信号，另一端能收到  
除了网线 还需要配置 两台电脑的 IP地址、子网掩码和默认网关 
两台电脑直接的网络包也需要 MAC层  IP层封装了MAC层才能将包放入物理层  
两台电脑已经构成了最小的局域网（LAN）  


广播的传送数据模式 —— 每一台电脑发出的包 局域网的每一台电脑都能收到就麻烦了：  
这个包是发送给谁的？谁应该接受？  
大家都在发 产生混乱怎么办？ 有没有先发后发的规则？  
如果发送的时候出现了错误 怎么办？    
上述问题都在第二层解决

**数据链路层（第二层）**  
数据链路层也即 MAC 层 全称 `medium access control`  
控制再往媒体上发送数据的时候 谁先发 谁后发的问题 防止混乱  很多算法可以解决这个问题  
- 分多个车道 每个车一个车道 你走你的 我走我的  `信道划分`  
- 今天单号出现 明天双号出现 轮着来 `轮流协议`
- 不管啥 有事先出门 发现特堵就回去 错过高峰再出行 `随机接入协议`  

发给谁？谁接受的问题 用物理地址 叫做 `链路层地址`  常被称为 `MAC地址`  
第二层网络包格式 就是目标 MAC地址 和源 MAC 地址  
大部分类型是`IP`数据包 里面包含了 `TCP` `UDP` 以及 `HTTP`  
有了目标 MAC地址 数据包在链路上广播 MAC网卡才能发现 这个包是给谁的  
MAC 网卡把包收进来 打开IP包 发现IP地址也是自己的 再打开TCP包 发现端口是 80（这里默认web开发 nginx监听80端口）  
将请求提交给 监听80端口的程序（nginx）  nginx 返回一个网页。然后将网页需要发回请求的机器  
然后层层封装 最后到 MAC 层 因为来的时候有源 MAC 地址 返回的时候，源 MAC 就变成了目标 MAC 再返给请求的机器 
这里还有一个问题  当源机器知道目标机器的时候 可以将目标地址放入包里 如果不知道呢？  
一个广播的网络里接入了 N 台机器 我怎么知道每个 MAC 地址是谁呢？  
这里需要 `ARP 协议`  就是 已知 IP 求 MAC地址的 协议  
在一个局域网里 知道了 IP 不知道 MAC 怎么办？  还是靠吼~~  
为了避免每次都使用 `ARP` 请求 机器本地也会进行缓存 当然缓存一段时间就会过期  

广播方式随着机器越来越多 产生的冲突概率也就提高了 而且把不需要的包转发过去 纯属浪费  
`交换机` -- 一台电脑将一个包发送给另一台电脑 当包到达交换机的时候也不知道地址 只能将包转发给除了来的那个电脑  
其他所有的电脑上  这里 `交换机就会记住 源电脑的地址` 以后有包的目的地是 这个 就直接发送  
这样交换机作为一个关卡一样  过一段时间之后 就有了整个网络的结构了 这时候就不用广播了 全部可以准确转发  
交换机的结果 我们称之为 `转发表` 也是有一个过期时间的  

随着新接入的电脑越来越多 交换机数目也越来越多  不可避免的出现一些意料不到的事  
常见的问题就是 `环路问题`  

![环路问题](https://github.com/wangcongyi/test/blob/master/images/j.png)

我们来想象一下机器 1 访问机器 2 的过程。一开始，机器 1 并不知道机器 2 的 MAC 地址，所以它需要发起一个 ARP 的广播。广播到达机器 2，机器 2 会把 MAC 地址返回来，看起来没有这两个交换机什么事情。但是问题来了，这两个交换机还是都能够收到广播包的。交换机 A 一开始是不知道机器 2 在哪个局域网的，所以它会把广播消息放到局域网二，在局域网二广播的时候，交换机 B 右边这个网口也是能够收到广播消息的。交换机 B 会将这个广播信息发送到局域网一。局域网一的这个广播消息，又会到达交换机 A 左边的这个接口。交换机 A 这个时候还是不知道机器 2 在哪个局域网，于是将广播包又转发到局域网二。左转左转左转，好像是个圈哦。可能有人会说，当两台交换机都能够逐渐学习到拓扑结构之后，是不是就可以了？别想了，压根儿学不会的。机器 1 的广播包到达交换机 A 和交换机 B 的时候，本来两个交换机都学会了机器 1 是在局域网一的，但是当交换机 A 将包广播到局域网二之后，交换机 B 右边的网口收到了来自交换机 A 的广播包。根据学习机制，这彻底损坏了交换机 B 的三观，刚才机器 1 还在左边的网口呢，怎么又出现在右边的网口呢？哦，那肯定是机器 1 换位置了，于是就误会了，交换机 B 就学会了，机器 1 是从右边这个网口来的，把刚才学习的那一条清理掉。同理，交换机 A 右边的网口，也能收到交换机 B 转发过来的广播包，同样也误会了，于是也学会了，机器 1 从右边的网口来，不是从左边的网口来。然而当广播包从左边的局域网一广播的时候，两个交换机再次刷新三观，原来机器 1 是在左边的，过一会儿，又发现不对，是在右边的，过一会，又发现不对，是在左边的。这还是一个包转来转去，每台机器都会发广播包，交换机转发也会复制广播包，当广播包越来越多的时候，按照上一节讲过一个共享道路的算法，也就是路会越来越堵，最后谁也别想走。所以，必须有一个方法解决环路的问题，怎么破除环路呢？

**STP 协议**  
在数据结构中 有一个方法叫做 `最小生成树`  将图中的环变成 树形结构  
全称 `spanning tree protocol`  
这个协议可以用 ‘华山论剑’ 来比喻

- 根交换机（root bridge） 
- 指定交换机 （designated bridges） 所谓的指定 就是 树枝
- 网桥协议数据单元 （bridge protocol data units） ‘相互比较实力’的协议 
- 优先级向量 （priority vector） ‘实力值越小越牛’ 实力值就是一组 ID 数据  

一开始 所有交互机都认为自己是掌门 每个网桥都被分配了一个 ID    
这个ID里有管理员分配的优先级知道哪些交换机好，就会给它们分配高的优先级  
既然都是掌门相互连接网线 就大家发送 `BPDU` 来比比武功呗  
赢的接着当掌门 输的就只好做小弟了  输的人就没有机会在继续发送 `BPDU` 了  
只有在收到掌门的 `BPDU` 时 转发一下 表示服从命令  
- 掌门继续比武 输掉的掌门会率领所有的小弟归顺 小的门派慢慢合并  
- 掌门有何能和自己的小弟相遇（说明已经存在`环`了） 小弟通过已经输掉的掌门拜在了你的门下  
只是掌门还不认识 发现这个小弟武功不错 不应该级别这么低  升职加薪吧~  
- 小弟与小弟相遇  比 谁和掌门的关系近 当大哥  
- 掌门和其他门派小弟相遇 赢了会逐渐拉拢和自己连接的兄弟 弃暗投明 输了 掌门就拜入门来  
- 不同门派小弟相遇 各自拿自己的掌门比较  
慢慢 武林统一 天下太平 生成一颗大树


#### MAC 地址

- MAC 地址是一个很容易让人‘误解’的地址，因为 MAC 地址号称全球唯一，不会有两个网卡有相同的 MAC 地址，  
很多人看到这里就会想，既然这样 整个互联网通信全部使用 MAC 地址就好了，但这样不行 `一个网络报要从一个传输到另一个地方，
除了需要确定的地址，还需要有定位功能`。 


