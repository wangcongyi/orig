# HTTP

> 三次握手 `在我看来 就是 你好 我好 大家好的 状态下 才能确定已经真正为连接做好准备`

- 第一次握手：建立连接，客户端发送 syn 包 到服务器，等待服务器确认
- 第二次握手：服务器收到 syn 包，确认客户端 SYN，同时也发送一个SYN 包，即 SYN + ACK 包
- 第三次握手：客户端收到服务器的 SYN + ACK 包，向服务器发送确认包 ACK 连接成功

  
  
> 四次挥手

- 客户端发送一个 FIN，用来关闭与服务器之间的数据传送
- 服务器收到 FIN，发回一个 ACK
- 服务器关闭与客户端的连接，发送一个 FIN
- 客户端发回 ACK 确认


为什么需要四次：
    这是因为服务端在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。而关闭连接时，当收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，己方也未必全部数据都发送给对方了，所以己方可以立即close，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送。


> 浏览器阻塞 (HOL blocking)

- 一般 PC 浏览器对单个域名的 server 同时建立 6~8 个连接，移动端上一般 4~6 个，所以 在大型网站上 一般会把静态资源放在不同于域名下，来加快浏览器渲染速度



> HTTP2.0

- 二进制分帧： HTTP2.0 的所有帧都采用二进制编码  
   1、帧：  客户端与服务器通过交换帧来通信，帧是基于新协议通信的最小单位  
   2、消息：指逻辑上的 HTTP 消息，比如请求、响应等由一个或多个帧组成  
   3、流：  流是连接中一个虚拟信道，可以承载双向消息；每个流都有一个唯一的整数标识符  
   
- 多路复用 Multiplexing  
    多路复用允许同时通过单一的 HTTP 连接发起多重 请求-响应 消息，有了新的分帧机制，不必再依赖多个 TCP 连接去实现多流并行。  
    每个数据流都拆分成很多互不依赖的帧(可以乱序发送，可以分优先级)

- 请求优先级  
    把 HTTP 消息分解为很多独立的帧之后，就可以通过优化这些帧的交错和传输顺序，每个流都可以带有一个31比特的优先值：0表示最高优先级，2^31-1 表示最低优先级  
    服务器可以根据流的优先级，控制分配资源，优先将最高优先级的帧发送给客户端

- header 压缩  
    HTTP1.X 的 header 带有大量信息，并且每次都要重复发送， HTTP2.0 使用 encoder 来减少需要传输的 header 大小，通讯顺发各自 cacha 一份 header fields 表   

- 服务器推送  
    一言以蔽之 就是 客户端请求 index.html，服务器吧所需要的资源随着 index.html 一起发送到客户端，省去了客户端请求的步骤。  
    服务器可以对一个客户端请求发送多个响应，无需客户端明确地请求。所有推送的资源都遵守同源策略   
