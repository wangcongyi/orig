## - 冒泡排序
```js
const arr = [5, 9, 3, 1, 2, 8, 4, 7, 6]

1、比较 arr[0] 与 arr[1] 如果 arr[0] < arr[1] 不交换他们的位置  
2、比较 arr[1] 与 arr[2] 如果 arr[1] > arr[2] 交换他们的位置  
3、arr ---->>>>> [5, 3, 9, 1, 2, 8, 4, 7, 6]  
4、arr ---->>>>> [5, 3, 1, 9, 2, 8, 4, 7, 6]  
.    
.   
.    
arr ---->>>>> [5, 3, 1, 2, 8, 4, 7, 6, 9]  
最大数在最右边，完成第一次排序，重复上述步骤....
```



## - 选择性排序  
  选择性排序依赖`线性搜索`：  
```js
  const arr = [3, 9, 8, 2, 1, 4, 6, 5, 7]  //  在数组中找到 6
                                           //  从头按顺序重复比较的简单方法
```

  选择性排序用`线性搜索`找到数组中最小值。将最小值替换为最左边的数字并进行排序  
 ```js
   [3, 9, 8, 2, 1, 4, 6, 5, 7]
   [1, 9, 8, 2, 3, 4, 6, 5, 7]  //  此时 1 已经完成排序，重复上述步骤.....
   [1, 2, 8, 9, 3, 4, 6, 5, 7]  //  2 与 9 交换位置
   .  
   .  
   .  
   .
 ```
 
 
 
 ## - 插入排序
   先默认最左边数字已经完成排序
 ```js
   [5, 3, 4, 7, 2, 8, 6, 9, 1]  //  取出第二个数字，与第一个数字比较，如果小于左边的数 交换
   [3, 5, 4, 7, 2, 8, 6, 9, 1]  //  取出第三个数字，与第二个数字比较，如果小于左边的数 交换
   [3, 4, 5, 7, 2, 8, 6, 9, 1]  //  取出第二个数字，与第一个数字比较，如果大于左边的数 停止
   .  
   .  
   .  
   .                            //  重复上述步骤，依次与左边的数进行比较，如果小于就交换，如果大于就停止
 ```
 


 ## - 归并排序
   将数组细分细分再细分，分而治之思想的典型
 ```js
             [6, 4, 3, 7, 5, 1, 2]            //   把数组分为两份
            [6, 4, 3, 7,    5, 1, 2]          //   继续分割知道不能再分
           [6, 4,   3, 7,   5, 1,   2]        //
         [6,   4,   3,   7,   5,   1,   2]    //  合并....按照升序移动
     
       [4, 6,   3, 7,   1,5,   2]        //  合并时候包含多个数字的组时，比较开头的数字，移动较小的数字
                                         //  比较 [4, 6]  [3, 7] 第一个数字  4 大于 3， 把 3 移动到合并数组的第一个
                                         //       [4, 6]  [7]    继续比较   4 小于 7， 把 4 移动到合并数组的第二个
                                         //          [6]  [7]    继续比较   6 小于 7， 把 6 移动到合并数组的第三个
        [3, 4, 6, 7,     1, 2, 5] 
 
 ```


![排序算法](https://images2018.cnblogs.com/blog/849589/201804/849589-20180402133438219-1946132192.png)
- 上面的图随处可见，但没有告诉我们怎么来的：
- 比如 归并排序 对于每个长度n≥1的输入数组，MergeSort 算法所执行的操作数量上界为 6nlog2n + 6n （详情可见 《算法详解》） 
我们给出了它的运行时间上限是6n log2 n + 6n 个基本操作，其中n表示输入数组的长度。这里的低阶项是6n，由于n的增长速度低于n log2 n，因此它在渐进性表示法中就被忽略。前面的常数因子6也被忽略，这样就产生了一个更简单的表达式n log n。然后，我们就可以声称MergeSort的运行时间是“n log n的大O时间”，写作O(n log n)，或者说MergeSort是一种“O(n log n)时间的算法”[1]。从直觉上说，对于一个函数f(n)，O(f(n))就是忽略了常数因子和低阶项之后剩余的内容[2]。这种大O表示法根据算法的渐进性最坏情况运行时间对它们进行分组：线性（O(n)）、O(n log n)时间算法、平方（O(n2)）时间算法、常数（O(1)）时间算法等  

![渐进性表示法](https://www.epubit.com/upload/write/App_Data/1812/1812afd1c431035c9d6a-Original-33.jpg)













